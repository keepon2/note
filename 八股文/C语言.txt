=============函数指针=====================
1. 不知道函数名，只知道函数地址 
回调函数参数	动态库
2. 制作函数指针表（函数指针数组）管理多个函数
多态性（虚函数表就是）
3.作为参数传递给其他函数
signal（）		pthread_create()

=============指针常量与常量指针==============
指针常量（要直接初始化）： 一般用于函数传参，确保传给函数的常量不被修改。
调用函数的人也知道不能改

常量指针：C++中引用和this指针，确保指针不会指向其他非法地址

=============strlen和sizeof================
strlen: 只能计算字符串的长度，不包括“\0”，遇到“\0”结束

sizeof: 计算类型大小

===========define、const、typedef=============
define：预处理，编译阶段之前进行文本替换（单纯文本替换）

const: 1.有数据类型  2.编译器有安全检测   3.可以调试

typedef： 区别名，使代码更易读，减少代码重复

============宏函数与函数=====================
宏函数： 效率高，没有函数调用开销，但是可读性非常差，容易出错
函数：可读性好，容易调试和维护，但函数调用有开销
拓展：在C++中内联函数可以规避开销，但是在编译阶段

============五种内存模型=====================
栈：局部变量、函数参数、返回地址
堆：动态内存的分配
.data：初始化的全局变量和static修饰的局部变量
.bss：未初始化的全局变量，和static修饰的局部变量
.rodata：常量区，只读数据段
.text：代码区

===============代码编译过程==================
1.预处理：#号开头的预处理指令
2.编译：将预处理后的源文件翻译成汇编代码
3.汇编：将汇编代码编译成目标文件
4.链接：将目标文件链接成可执行文件
gcc -E text.c -o text.i
gcc -S text.i -o text.s
gcc -c text.s -o text.o
ld text.o -o text

================堆和栈=====================
数据结构-----------------内存管理
堆：手动分配和释放，通过指针访问，速度慢，空间容量大
栈：系统分配释放，速度快，空间容量小

在数据结构中：
堆：二叉树（大顶堆，小顶堆）
栈：顺序栈，链式栈，先进后出

================const======================
注：声明常量，const修饰变量的数值在程序执行期间不能被修改
1. 常量声明：
2. 函数参数：防止函数修改参数
3. 指针： 常量指针、指针常量
4. 成员函数（C++）：该函数不会修改对象状态

作用：提高函数的健壮性和可读性，一般能加上就都加上

================static======================
1. 修饰局部变量： 扩大生命周期
2. 修饰全局变量： 只能在当前文件内访问
3. 修饰函数： 该函数只能在当前文件可见

作用：限制变量或函数作用域

================内存分配方式=================
1. 从静态储存区域分配
2. 栈分配
3. 堆分配

=========================================
一个有十个指针的数组，该指针指向的是一个整形数
int *arr[10]
一个指向有十个整型数组的指针
int (*arr)[10]
一个指向函数的指针，该函数有一个整形参数并返回一个整形数
int (*arr)(int a)
一个有10个指针的数组，该指针指向一个函数，该函数有一个整形参数并返回一个整型数
int (*arr[10])(int a)

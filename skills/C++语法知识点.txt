带默认值的函数：
必须从右到左设置默认值
一般写在函数声明的位置

带占位参数的函数：
作用：为了函数以后的扩展，解决c中不规范函数传参
语法：int function(int a, int b, int);
调用函数的时候必须参这个参数
-----------------------------------------------------------------------------------------------------------------
函数重载：
作用：减少函数名的数量，提高程序的可读性
规则：1、必须在同一个作用域内
	  2、函数名必须相同
	  3、参树列表必须不同（个数不同，类型不同）
底层原理：编译会将重载函数设置成不同的函数名，根据参数类型与个数进行匹配
-----------------------------------------------------------------------------------------------------------------
左值：
永久对象，可以存在于=左边的值，可以取地址

右值：
临时对象（即将销毁），不能存在于=左边的值，不可以取地址
简单来说没有名称且无法获取存储地址的对象称为右值

左值引用：
作用：1、主要用于函数传参
			代替指针，在函数体内修改变量的值
			传参为const引用，主要用于高代码性能
	  2、用于函数返回
			返回的数据不能在函数结束时消亡
			引用返回，函数可以做左值，也可以做右值（注意：返回值不能是const引用）
	  3、对数组的引用
	  4、对指针的引用

右值引用：
右值引用必须绑定到右值的引用，使用&&获得右值引用

引用在C++中提供了一种灵活且高效的方式来处理变量，极大地方便了程序设计。

指针和引用的区别不同点：

1. 引用概念上定义一个变量的别名，指针存储一个变量地址

2. 引用在定义时必须初始化，指针没有要求

3. 引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何一个同类型 实体

4. 没有NULL引用，但有NULL指针

5. 在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数(32位平台下占 4个字节)

6. 引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小

7. 指针有多级指针，但是引用没有多级引用

8. 访问实体方式不同，指针需要显式解引用，引用编译器自己处理

9. 引用比指针使用起来相对更安全
-----------------------------------------------------------------------------------------------------------------

new和delete：
作用：申请内存并初始化对象，释放内存并销毁对象
new的时候调用构造函数，delete的时候调用析构函数
语法：int *p = new int;
	  *p = 10;
	  delete;
	数组：
	int *p = new int[5]{1,2,3,4,5}; //大括号初始化法：c++11之后才有的
	cout << p[0] << endl;
	delete []p;
	
-----------------------------------------------------------------------------------------------------------------
	
	
类：
对某一事务的抽象

对象：
某一事物的个体，具体且唯一
创建对象后才会分配内存空间

在 C++ 中，类的内存分配是在对象创建时进行的，而不是在类定义时。
具体来说，当你定义一个类时，编译器会根据类的成员变量和其他信息【计算出该类对象的大小】，
但这个过程并不分配内存。
内存分配的实际发生是在你创建对象的时候。

权限：
public:		公有的，对象可直接使用	
private:	私有的，对象无法直接使用
protected:	受保护的，和私有差不多，只有在继承中才会体现区别
-----------------------------------------------------------------------------------------------------------------
this指针：
用于保存对象的地址，每个非静态函数中都有一个隐藏的参数this
成员函数访问对象内的成员是通过this指针访问的
-----------------------------------------------------------------------------------------------------------------
构造函数：
在构造对象时自动调用此函数，往往用来初始化对象内的成员变量
变量初始化的顺序以变量在类中定义的顺序为准

默认构造函数：
类中没有构造函数时，自动生成的
Circle::Circle(int x, int y, int r):x(x), y(y), r(r) //初始化列表
{	
}	

委托构造函数：c++11之后的
目的：一个类重构多个构造函数，并且每个构造函数都需要对某些变量进行初始，这时候就会出现重复代码
// 委托构造函数，使用默认值委托给已有的构造函数  
Circle() : Circle(0, 0, 1) // 默认位置 (0, 0) 和半径 1  
{	
} 

拷贝构造函数：
浅拷贝：只复制对象的基本数据成员，而对于指针等复杂数据类型，仅复制它们的地址（指针本身的值）
		。这意味着原对象和拷贝对象共享同一内存位置的资源。
深拷贝：在复制对象时，所有的基本数据成员会被复制，并且对于指针等复杂数据类型，深拷贝会创建指向新内存区域的副本
		。这意味着原对象和拷贝对象拥有各自独立的资源。
浅拷贝在析构时可能会出现问题
作用：主动创建对象时，用一个对象去初始化另外一个对象的时候  
Circle(const Circle& other) : x(other.x), y(other.y), r(other.r) {  
	std::cout << "Copy Constructor called" << std::endl;  
}
	
移动构造函数：
接受一个右值引用 other，并将 other 的成员变量值转移到当前对象。
移动后，重置 other 的成员变量，以避免在访问之前发生未定义行为。
Circle(Circle&& other) noexcept : x(other.x), y(other.y), r(other.r) {  
	std::cout << "Move Constructor called" << std::endl;  
	// 将其他对象的资源移到当前对象后，清空其他对象的状态  
	other.x = 0;  
	other.y = 0;  
	other.r = 0;  
}
Circle c4 = std::move(c2); 	
move是一个标准库提供的工具，它通过将其参数转换为右值引用
Circle c4 = Circle(5, 5, 2); // 通过临时对象来调用移动构造函数	
-----------------------------------------------------------------------------------------------------------------	
析构函数:
在销毁对象的时候自动调用，往往用来释放对象内申请的资源
Circle::~Circle()
{
	
}
没有参数和返回值，但有this指针
不能被const修饰
-----------------------------------------------------------------------------------------------------------------
explicit:
只能用来修饰类的构造函数，且最好只修饰只有一个参数的构造函数
被修饰的构造函数不能发生相应的隐式类型转换，只能以显示的方式进行类型转化
作用：以防止编译器在不经意间进行隐式类型转换。确保构造函数只能被显式地调用，而不是作为隐式转换的一部分。
-----------------------------------------------------------------------------------------------------------------	
static:
作用：用于修饰成员变量和成员函数
修饰成员变量：
	1、static成员变量属于类的不属于对象
	2、static成员变量的内存在程序开始运行时分配，程序运行结束时释放
	3、staiic成员变量对于所有的对象是共享的，并在对象创建之前就已经产生了
	4、静态成员变量使用前必须初始化，否则在链接步骤就会出错
	5、类内的静态成员变量一定要在类外进行初始化，不加static：int Circle::a = 10；
	6、在成员函数中可以正常访问静态成员变量
修饰成员函数：
	1、可以被对象直接使用
	2、可以通过类名直接访问
	3、不能使用this指针，与类关联，不与对象关联，在调用静态函数时，可以在没有对象时调用
	4、不能访问非静态成员，只能访问静态成员
何时使用static：
	1、一切不需要实例化就可以确定行为方式的函数都应该设计成静态的
	2、通过其他类型的对象转换成自己类型的对象一般使用静态成员函数生成
	
-----------------------------------------------------------------------------------------------------------------
	
const:
成员变量：只能在初始化列表中初始化，一定要初始化
成员函数：
	本质实际上是修饰的this指针
	作用：防止成员函数修改非静态成员变量的值
	const修饰的成员函数只能调用const修饰的成员函数
	const修饰的成员函数可以访问非静态成员变量，但是不能修改
	能够和同名的不带const的函数构成函数重载（本质上还是参数列表不同）
	const A a;		a.constShow() 可以	a.show() 不可以 ：常对象只能调用常成员函数
修饰返回值
	
-----------------------------------------------------------------------------------------------------------------
	
友元函数：
友元函数不是成员函数，它定义在类的外部，只需要在类中声明即可
友元函数可以访问所有私有成员和保护成员，一般情况下不去使用，使用不当会破坏程序面向对象的特性
	
友元类：
友元是单向的

#include <iostream>

using namespace std;

class DaXiong
{
public:
    DaXiong() : comic("OnePiece")
    {

    }
    friend class PangHu;
    void playBall(PangHu ph)
    {
        cout << "play" << ph.ball << endl;
    }
private:
    string comic;
};
class PangHu
{
public:
    PangHu() : ball("baseball")
    {

    }
    friend class DaXiong;
    void readComic(DaXiong dx)
    {
        cout << "read" << dx.comic << endl;
    }
private:
    string ball;
};
int main()
{
    DaXiong dx;
    PangHu ph;
    ph.readComic(dx);
    dx.playBall(ph);
    return 0;
}
bug：‘PangHu’ has not been declared，void playBall(PangHu ph)
该错误的原因是 C++ 语言在编译时需要知道所有数据类型的信息。
在你提供的代码中，DaXiong 类中定义的 playBall 方法需要 PangHu 类型的参数，
但在 DaXiong 类的定义中，PangHu 类还没有被声明。
因此，编译器在遇到 playBall 方法时不理解 PangHu 是什么类型，从而导致错误。
解决方法：前向声明   将函数定义移到类外
	
-----------------------------------------------------------------------------------------------------------------
	
运算符重载：
不可重载的运算符：
	.		:成员访问运算符
	.*,->*	:成员指针访问运算符
	::		:域运算符
	sizeof	:长度运算符
	?:		:条件运算符（三目运算符）
	#		:预处理符号
运算符重载函数的参数列表不能带默认值
-----------------------------------------------------------------------------------------------------------------
	
继承：从已有的类派生出新的类
基类的构造函数、拷贝函数与析构函数
基类的重载运算符
基类的友元函数
 ----- 无法被继承
作用：	
代码重用：通过继承，子类可以直接使用父类的方法和属性，减少代码重复。
增强可维护性：如果父类的功能需要更改，只需在一个地方修改，所有子类都会自动使用更新后的功能。
多态性：通过继承，可以实现多态，使得相同的接口可以被不同的对象实现，有利于编写灵活的代码。
建模现实世界：继承使得程序员可以更好地模拟现实世界中的层次结构和关系。
语法：
class Parent
{}
class Child : public Parent
{}
原理：
类关系：继承建立了父类和子类之间的层次关系。子类可以访问父类的公共和保护成员。
方法重写：子类可以重写父类的方法，提供特定的实现。
动态绑定：在运行时，程序能够决定调用哪个类的方法（尤其是在实现多态时）。
构造函数和析构函数：当创建子类对象时，父类的构造函数会先被调用，之后是子类的构造函数。析构时顺序相反。
-----------------------------------------------------------------------------------------------------------------


	A
B		C
	D
菱形继承问题：会产生数据冗余(A被定义两遍)、成员访问的二义性(A可以被B和C访问)
B,C继承A是虚拟继承:引入了特定的构造顺序规则


虚继承：
在初始化A的时候，只能在D的初始化列表初始化A

-----------------------------------------------------------------------------------------------------------------	
	
私有继承和保护继承：
私有成员被继承后无法直接访问
保护成员被继承后可以直接访问
以高级的权限为主，权限只能升不能降（public < protected < private）
	
保护继承：
通过保护继承，基类的公有成员和保护成员在派生类中都变为保护成员。基类的私有成员依然无法访问。
	
-----------------------------------------------------------------------------------------------------------------	
	
类和类的关系：
is-a:	公有继承
has-a:	组合	保护/私有继承
use-a:	函数传参

组合的核心是一个类包含其他类的实例。这使得外部类可以利用内部类的功能。

-----------------------------------------------------------------------------------------------------------------
	
多态：同一个接口可以有多种不同的实现，可以提高代码的灵活性
在c++，一般针对一个行为只会有一个名称，是对类的行为在抽象，主要作用在于统一行为的接口，提高方法的通用行为

静态多态(编译时多态)-----函数重载 或 泛型编程实现
静态绑定(静态联编)-----在编译时就能确定的行为

动态多态(运行时多态)-----继承 和 虚函数实现，必须是【父类指针或引用】指向子类对象，然后调虚函数
动态绑定(动态联编)-----在运行时才能确定的行为

-----------------------------------------------------------------------------------------------------------------

虚函数：实现动态多态
原理：虚函数表

virtual 虚函数关键字，只能在声明的时候添加
类的静态成员函数不能被定义为虚函数
非类的成员函数不能被定义为虚函数
当将基类的某一成员函数声明成虚函数后，派生类的同名函数自动成为虚函数

成员函数覆盖(override)，也称重写	通过父类指针或引用指向子类对象
	特点：
		不同作用域(分别位于派生类与基类)
		函数名相同
		参数相同
		返回值相同
		基类必须有virtual
		重写函数的权限访问限定符可以不同
函数重载(overload)
	特点：
		同一作用域
		函数名相同
		参数不同
		返回值无所谓
		virtual关键字无所谓
成员函数隐藏(hiding)				子类对象直接调用重新实现的与父类函数名同名的函数
	特点：
		不同作用域(分别位于派生类与基类)
		函数名相同
		返回值无所谓
		参数无所谓

虚析构函数：
构造函数不能是虚函数，但是建议将父类的析构函数设置为虚函数(没儿子就不用，没多态也不用)
当基类的指针指向派生类对象时，如果析构函数不是虚函数，则不会发生动态多态，而导致只会调用基类的析构函数，
造成内存泄漏

-----------------------------------------------------------------------------------------------------------------

抽象类和纯虚函数：
含纯虚函数的类就是抽象类
抽象类是一种无法实例化的类
它主要用于定义接口和规范，同时提供部分实现。
抽象类通常包含一个或多个纯虚函数（即没有实现的虚函数），这些纯虚函数在派生类中必须被重写（实现）
在C++中，纯虚函数通过在其声明后加上 = 0
















	
	
	
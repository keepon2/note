=====================字符驱动开发==================
字符设备就是一个一个字节，按照字节流进行读写操作的设备，读写数据是分先后顺序的。

文件系统
根文件系统  
VFS:凌驾于文件系统之上，把实际的物理设备抽象成一个设备文件


------------------------------向上层提供函数接口的形式----------------------
写驱动的目的是需要为上层提供接口，来操作模块，也就是操作硬件。

函数指针。
提供函数接口，无非就是写很多很多函数。

好处就是可以实现“高类聚，低耦合”，将调用者和被调用者分隔开，调用者不关心
谁是被调用者，它只需要知道一个具有特点原型和限制条件的被调用函数。
特点二：解耦合
高内聚：将类型相同或功能相同的写到一个结构体或类中

----------------------------字符设备的接口提供-------------------------------
struct file_operations {
	常见的open，read，write，close等等对设备操作提供的接⼝
	.open = open_led_device,
	.read = read_led_devece,
}
结构体类都是函数指针
'.'的意思：可以理解成指针指向结构体类的对应的函数。

---------------------------------cdev结构体--------------------------------
dev_t  本质上是unsigned int类型 32位
设备号：12bit主设备号 + 20次设备号

内核里面有一个专门管理所有字符设备的cdev map

kmalloc分配内存，然后关联我们自己的file_operations 结构体


---------------------------------注册设备号--------------------------------
内核中有对应的函数
注册设备号： register_chrdev_region
宏 MAJOR 用于从 dev_t 中获取主设备号，将 dev_t 右移 20 位即可。
宏 MINOR 用于从 dev_t 中获取次设备号，取 dev_t 的低 20 位的值即可
宏 MKDEV 用于将给定的主设备号和次设备号的值组合成 dev_t 类型的设备号。

分配设备号有手动分配和自动分配
手动：宏定义主设备号和次设备号，不能冲突
自动：alloc_chrdev_region

--------------------------------设备号和cdev关联------------------------















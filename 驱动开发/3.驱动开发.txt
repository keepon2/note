================Linux设备驱动开发====================
驱动：裸机驱动和linux驱动（现在就是学Linux驱动）
逻辑驱动：驱动和逻辑代码联系在一起，它是直接操作控制器让硬件工作
linux驱动：提供给应用层的访问硬件的函数接口（操作方法）。
Linux驱动 = 框架 + 裸机驱动

字符设备：顺序依次进行访问的设备，读写以字节为单位（串口，IIC，音频，SPI）
块设备：以数据块的形式存放数据，块设备上层通常会加入磁盘文件系统，所以得支持随机存取。（U盘，emmc，nand，SD，硬盘）
特点：数据固定长度，随机存取，可以容纳文件系统
网络设备：通过网络套接字来实现网络数据的接收和发送，单独的网络接口

linux驱动的本质 向应用层提供操作硬件方法的函数接口

samba服务



--------------------------------编译文件------------------------------------------
我们写好驱动文件（led_driver.c)后
1.我们首先想到用gcc编译尝试，会报错（缺少linux/init.h头文件）
这是因为我们写的是linux内核的代码，用的是驱动代码框架，
而gcc编译的是用户空间运行的程序。
------------------------------两种使用方式（静态/动态）----------------------------------------
1.将自己编写的代码，拷贝到Linux内核源码中，然后添加配置，就像系统移植课程中，写一个
makefile和Kconfig,然后通过make menuconfig进行选择，最后编译进内核。
2.自己编写Makefile，然后使用linux内核的编译系统，编译自己的代码。
第一种方式一般用于调试完成后，添加代码到内核中，如果还是在研发测试阶段，直接添加那么
多东西不方便，且后续如果想删除可能操作遗漏等等误操作问题，所以一般我们在调试的时候可
以先用第二种方式进行研发。


MAKE -C  : 切换编译

-------------------------------驱动模块的使用命令----------------------------------------
modinfo + 模块	查看相关信息
insmode + 模块	加载模块（可以有参数）
lsmod 		显示已加载模块
dmesg		查看和控制内核的缓冲区（dmesg -c:清除前面的）
rmmod + 模块	卸载模块


